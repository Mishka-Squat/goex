// Code generated by go run decgen.go -output dec_helpers.go; DO NOT EDIT.

// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gobex

import (
	"fmt"
	"math"
	"reflect"
)

var errCanAddr = fmt.Errorf("not addressable")
var errWrongType = fmt.Errorf("wrong type")

var decArrayHelper = map[reflect.Kind]decHelper{
	reflect.Bool:       decBoolArray,
	reflect.Complex64:  decComplex64Array,
	reflect.Complex128: decComplex128Array,
	reflect.Float32:    decFloat32Array,
	reflect.Float64:    decFloat64Array,
	reflect.Int:        decIntArray,
	reflect.Int16:      decInt16Array,
	reflect.Int32:      decInt32Array,
	reflect.Int64:      decInt64Array,
	reflect.Int8:       decInt8Array,
	reflect.String:     decStringArray,
	reflect.Uint:       decUintArray,
	reflect.Uint16:     decUint16Array,
	reflect.Uint32:     decUint32Array,
	reflect.Uint64:     decUint64Array,
	reflect.Uintptr:    decUintptrArray,
}

var decSliceHelper = map[reflect.Kind]decHelper{
	reflect.Bool:       decBoolSlice,
	reflect.Complex64:  decComplex64Slice,
	reflect.Complex128: decComplex128Slice,
	reflect.Float32:    decFloat32Slice,
	reflect.Float64:    decFloat64Slice,
	reflect.Int:        decIntSlice,
	reflect.Int16:      decInt16Slice,
	reflect.Int32:      decInt32Slice,
	reflect.Int64:      decInt64Slice,
	reflect.Int8:       decInt8Slice,
	reflect.String:     decStringSlice,
	reflect.Uint:       decUintSlice,
	reflect.Uint16:     decUint16Slice,
	reflect.Uint32:     decUint32Slice,
	reflect.Uint64:     decUint64Slice,
	reflect.Uintptr:    decUintptrSlice,
}

func decBoolArray(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decBoolSlice(state, v.Slice(0, v.Len()), length)
}

func decBoolSlice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]bool](v)
	if !ok {
		// It is kind bool but not type bool. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding bool array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		slice[i] = state.decodeUint() != 0
	}
	return nil
}

func decComplex64Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decComplex64Slice(state, v.Slice(0, v.Len()), length)
}

func decComplex64Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]complex64](v)
	if !ok {
		// It is kind complex64 but not type complex64. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding complex64 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		real, err := float32FromBits(state.decodeUint())
		if err != nil {
			return err
		}
		imag, err := float32FromBits(state.decodeUint())
		if err != nil {
			return err
		}
		slice[i] = complex(float32(real), float32(imag))
	}
	return nil
}

func decComplex128Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decComplex128Slice(state, v.Slice(0, v.Len()), length)
}

func decComplex128Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]complex128](v)
	if !ok {
		// It is kind complex128 but not type complex128. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding complex128 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		real, err := float64FromBits(state.decodeUint())
		if err != nil {
			return err
		}
		imag, err := float64FromBits(state.decodeUint())
		if err != nil {
			return err
		}
		slice[i] = complex(real, imag)
	}
	return nil
}

func decFloat32Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decFloat32Slice(state, v.Slice(0, v.Len()), length)
}

func decFloat32Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]float32](v)
	if !ok {
		// It is kind float32 but not type float32. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding float32 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		v, err := float32FromBits(state.decodeUint())
		if err != nil {
			return err
		}
		slice[i] = float32(v)
	}
	return nil
}

func decFloat64Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decFloat64Slice(state, v.Slice(0, v.Len()), length)
}

func decFloat64Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]float64](v)
	if !ok {
		// It is kind float64 but not type float64. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding float64 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		v, err := float64FromBits(state.decodeUint())
		if err != nil {
			return err
		}
		slice[i] = v
	}
	return nil
}

func decIntArray(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decIntSlice(state, v.Slice(0, v.Len()), length)
}

func decIntSlice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]int](v)
	if !ok {
		// It is kind int but not type int. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding int array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		x := state.decodeInt()
		// MinInt and MaxInt
		if x < ^int64(^uint(0)>>1) || int64(^uint(0)>>1) < x {
			return errOverflow
		}
		slice[i] = int(x)
	}
	return nil
}

func decInt16Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decInt16Slice(state, v.Slice(0, v.Len()), length)
}

func decInt16Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]int16](v)
	if !ok {
		// It is kind int16 but not type int16. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding int16 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		x := state.decodeInt()
		if x < math.MinInt16 || math.MaxInt16 < x {
			return errOverflow
		}
		slice[i] = int16(x)
	}
	return nil
}

func decInt32Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decInt32Slice(state, v.Slice(0, v.Len()), length)
}

func decInt32Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]int32](v)
	if !ok {
		// It is kind int32 but not type int32. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding int32 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		x := state.decodeInt()
		if x < math.MinInt32 || math.MaxInt32 < x {
			return errOverflow
		}
		slice[i] = int32(x)
	}
	return nil
}

func decInt64Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decInt64Slice(state, v.Slice(0, v.Len()), length)
}

func decInt64Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]int64](v)
	if !ok {
		// It is kind int64 but not type int64. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding int64 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		slice[i] = state.decodeInt()
	}
	return nil
}

func decInt8Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decInt8Slice(state, v.Slice(0, v.Len()), length)
}

func decInt8Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]int8](v)
	if !ok {
		// It is kind int8 but not type int8. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding int8 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		x := state.decodeInt()
		if x < math.MinInt8 || math.MaxInt8 < x {
			return errOverflow
		}
		slice[i] = int8(x)
	}
	return nil
}

func decStringArray(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decStringSlice(state, v.Slice(0, v.Len()), length)
}

func decStringSlice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]string](v)
	if !ok {
		// It is kind string but not type string. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding string array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		u := state.decodeUint()
		n := int(u)
		if n < 0 || uint64(n) != u || n > state.b.Len() {
			errorf("length of string exceeds input size (%d bytes)", u)
		}
		if n > state.b.Len() {
			errorf("string data too long for buffer: %d", n)
		}
		// Read the data.
		data := state.b.Bytes()
		if len(data) < n {
			errorf("invalid string length %d: exceeds input size %d", n, len(data))
		}
		slice[i] = string(data[:n])
		state.b.Drop(n)
	}
	return nil
}

func decUintArray(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decUintSlice(state, v.Slice(0, v.Len()), length)
}

func decUintSlice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]uint](v)
	if !ok {
		// It is kind uint but not type uint. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding uint array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		x := state.decodeUint()
		/*TODO if math.MaxUint32 < x {
			return errOverflow
		}*/
		slice[i] = uint(x)
	}
	return nil
}

func decUint16Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decUint16Slice(state, v.Slice(0, v.Len()), length)
}

func decUint16Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]uint16](v)
	if !ok {
		// It is kind uint16 but not type uint16. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding uint16 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		x := state.decodeUint()
		if math.MaxUint16 < x {
			return errOverflow
		}
		slice[i] = uint16(x)
	}
	return nil
}

func decUint32Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decUint32Slice(state, v.Slice(0, v.Len()), length)
}

func decUint32Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]uint32](v)
	if !ok {
		// It is kind uint32 but not type uint32. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding uint32 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		x := state.decodeUint()
		if math.MaxUint32 < x {
			return errOverflow
		}
		slice[i] = uint32(x)
	}
	return nil
}

func decUint64Array(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decUint64Slice(state, v.Slice(0, v.Len()), length)
}

func decUint64Slice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]uint64](v)
	if !ok {
		// It is kind uint64 but not type uint64. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding uint64 array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		slice[i] = state.decodeUint()
	}
	return nil
}

func decUintptrArray(state *decoderState, v reflect.Value, length int) error {
	// Can only slice if it is addressable.
	if !v.CanAddr() {
		return errCanAddr
	}
	return decUintptrSlice(state, v.Slice(0, v.Len()), length)
}

func decUintptrSlice(state *decoderState, v reflect.Value, length int) error {
	slice, ok := reflect.TypeAssert[[]uintptr](v)
	if !ok {
		// It is kind uintptr but not type uintptr. TODO: We can handle this unsafely.
		return errWrongType
	}
	for i := 0; i < length; i++ {
		if state.b.Len() == 0 {
			errorf("decoding uintptr array or slice: length exceeds input size (%d elements)", length)
		}
		if i >= len(slice) {
			// This is a slice that we only partially allocated.
			growSlice(v, &slice, length)
		}
		x := state.decodeUint()
		if uint64(^uintptr(0)) < x {
			return errOverflow
		}
		slice[i] = uintptr(x)
	}
	return nil
}

// growSlice is called for a slice that we only partially allocated,
// to grow it up to length.
func growSlice[E any](v reflect.Value, ps *[]E, length int) {
	var zero E
	s := *ps
	s = append(s, zero)
	cp := cap(s)
	if cp > length {
		cp = length
	}
	s = s[:cp]
	v.Set(reflect.ValueOf(s))
	*ps = s
}
